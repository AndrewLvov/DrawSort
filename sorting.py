# cb: callback
def sort_array(array, cb):
    # n-1 проходов
    for i in range(len(array)-1, 0, -1):
        # 1 ... n-1 проходов для каждого внешнего прохода
        for j in range(0, i):
            if array[j] > array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]

        cb(array)

    # 1 + 2 + ... + n-1
    # Сложность: (n-1)(n-2)/2, O(n^2)
    # Компания из n человек
    # рукопожатий: n-1 + n-2+ ... + 1, (n-1)(n-2)/2, O(n^2)

    # сортировка слиянием
    # Сложность: O(n*log2(n))

    # константная сложность O(1)
    # Пример: доступ до элемента массива по индексу
    # arr = [1, -5, 'a', 4, 'b', 'q', ..., 4]
    # arr[3]
    # dict1 = {'a': 5, 'b': 0, 'c': 3}
    # dict1['a'] - в большинстве случаев константная

    # Сложность O(log2(n))
    # Пример: поиск по бинарному дереву

    # Сложность O(n!)
    # лохо(перечёркнуто).... лототрон: для генерирования всех возможных комбинаций
    # Сколько вариантов комбинаций из n шаров
    # 'a', 'b', 'c', 'd', 'e'
    # 'a', ('b', 'c', 'd', 'e')
    # 'b', ('a', 'c', 'd', 'e')
    # ...
    # 'e', (...)
    # n * combs(n-1) ... = n!

        pass
    # int64, 64 бита для хранения данных
    # 1: 1
    # 2: 2
    # 3: 6
    # 4: 24
    # 5: 120
    # 6: 720
    # 7: 5040
    # 8: 40320
    # 9: 362880
    # 10: 3628800
    # ...
    # 13: 3 млрд
    # 16: > 3 трл.
